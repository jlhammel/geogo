{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geogo","text":"<p>A python package for geospatial analysis and mapping hurricane tracks</p> <ul> <li>Free software: MIT License</li> <li>GitHub repo: https://github.com/jlhammel/geogo</li> <li> <p>Documentation: https://jlhammel.github.io/geogo</p> </li> <li> <p>Geogo is a Python package meant for climatologists to analyze hurricane data from HURDAT2. Geogo uses ipyleaflet to create interactive maps for analysis. This package will allow you to use WMS, raster, geojson, image, and video files to further understand the impact of past hurricanes. Using interactive maps, hurricane track data from the Python package tropycal, and NASA GIBS data the user can track the hurricane and analyze the landscape around the impacted areas.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements:","text":"<ul> <li>fiona</li> <li>folium</li> <li>geopandas</li> <li>ipyleaflet</li> <li>leafmap</li> <li>localtileserver</li> <li>mapclassify</li> <li>matplotlib</li> <li>numpy</li> <li>tropycal</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Process geospatial data</li> <li>Track past hurricanes impacting the Americas</li> <li>Analyse hurricanes using images, raster, video, WMS and geojson files</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p><pre><code>import geogo\nimport os\n</code></pre> - Install from GitHub   <pre><code>pip install git+https://github.com/jlhammel/geogo\n</code></pre></p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geogo.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geogo/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jlhammel/geogo/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geogo could always use more documentation, whether as part of the official geogo docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jlhammel/geogo/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geogo for local development.</p> <ol> <li> <p>Fork the geogo repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geogo.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geogo\n$ cd geogo/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geogo tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/jlhammel/geogo/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliummap/","title":"foliummap module","text":"<p>This module provides a custom Map class that extends the folium.Map class</p>"},{"location":"foliummap/#geogo.foliummap.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>geogo/foliummap.py</code> <pre><code>class Map(folium.Map):\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n        \"\"\"\n\n        url = eval(f\"folium.basemaps.{basemap}\").build_url()\n        layer = folium.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Add a GeoJSON layer to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n            zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n            hover_style (_type_, optional): Changes color when hover over place on map.. Defaults to None.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Add a shapefile to the map.\n\n        Args:\n            data (_type_): The file path to the shapefile.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Add a GeoDataFrame to the map.\n\n        Args:\n            gdf (_type_): The GeoDataFrame to add.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    # def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    #     \"\"\"Add split map to compare two maps.\n\n    #     Args:\n    #         left (str, optional): Map type on the left of the map. Defaults to 'openstreetmap'.\n    #         right (str, optional): Map type on the right of the map. Defaults to 'cartodbpositron'.\n    #     \"\"\"\n    #     layer_right = folium.TileLayer(left, **kwargs)\n    #     layer_left = folium.TileLayer(right, **kwargs)\n\n    #     sbs = folium.plugins.SideBySideLayers(\n    #         layer_left=layer_left, layer_right=layer_right\n    #     )\n\n    #     layer_left.add_to(self)\n    #     layer_right.add_to(self)\n    #     sbs.add_to(self)\n\n    # def add_raster(self, left, right, **kwargs):\n    #     \"\"\"Add raster data to maps.\n\n    #     Args:\n    #         left (_type_): Add raster data to the left of the map.\n    #         right (_type_):Add raster data to the right of the map.\n    #     \"\"\"\n    #     from localtileserver import TileClient, get_folium_tile_layer\n\n    #     right_layer = get_folium_tile_layer(right, **kwargs)\n    #     left_layer = get_folium_tile_layer(left, **kwargs)\n\n    #     sbs = folium.plugins.SideBySideLayers(\n    #         layer_left=left_layer, layer_right=right_layer\n    #     )\n\n    #     left_layer.add_to(self)\n    #     right_layer.add_to(self)\n    #     sbs.add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"Adds a split map to the map.\n\n        Args:\n            left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n            right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n        \"\"\"\n        from localtileserver import get_folium_tile_layer\n\n        if left.startswith(\"http\") or os.path.exists(left):\n            layer_left = get_folium_tile_layer(left, **kwargs)\n        else:\n            layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n        if right.startswith(\"http\") or os.path.exists(right):\n            layer_right = get_folium_tile_layer(right, **kwargs)\n        else:\n            layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n    \"\"\"\n\n    url = eval(f\"folium.basemaps.{basemap}\").build_url()\n    layer = folium.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Add a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>_type_</code> <p>The GeoDataFrame to add.</p> required Source code in <code>geogo/foliummap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Add a GeoDataFrame to the map.\n\n    Args:\n        gdf (_type_): The GeoDataFrame to add.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Add a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Zoom in to the layer on the map. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>_type_</code> <p>Changes color when hover over place on map.. Defaults to None.</p> <code>None</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Add a GeoJSON layer to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n        zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n        hover_style (_type_, optional): Changes color when hover over place on map.. Defaults to None.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control to the map.</p> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Add a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>The file path to the shapefile.</p> required Source code in <code>geogo/foliummap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Add a shapefile to the map.\n\n    Args:\n        data (_type_): The file path to the shapefile.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Adds a split map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The tile layer for the left side of the split map. Defaults to \"openstreetmap\".</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".</p> <code>'cartodbpositron'</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"Adds a split map to the map.\n\n    Args:\n        left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n        right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n    \"\"\"\n    from localtileserver import get_folium_tile_layer\n\n    if left.startswith(\"http\") or os.path.exists(left):\n        layer_left = get_folium_tile_layer(left, **kwargs)\n    else:\n        layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n    if right.startswith(\"http\") or os.path.exists(right):\n        layer_right = get_folium_tile_layer(right, **kwargs)\n    else:\n        layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"geogo/","title":"geogo module","text":"<p>Main module.</p>"},{"location":"geogo/#geogo.geogo.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>geogo/geogo.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenStreetMap.Mapnik\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_tropycal_storm(\n        self,\n        name_or_tuple,\n        basin=\"north_atlantic\",\n        source=\"hurdat\",\n        zoom_to_layer=True,\n    ):\n        \"\"\"Adds a storm track to the map using Tropycal.\n        Args:\n            name_or_tuple (str or tuple): The name of the storm or a tuple containing the name and year.\n            basin (str, optional): The basin of the storm. Defaults to 'north_atlantic'.\n            source (str, optional): The source of the storm data. Defaults to 'hurdat'.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it. Defaults to True.\n        \"\"\"\n        import tropycal.tracks as tracks\n        import geopandas as gpd\n        from shapely.geometry import Point, LineString\n        import pandas as pd\n\n        category_colors = {\n            \"TD\": \"#6baed6\",\n            \"TS\": \"#3182bd\",\n            \"C1\": \"#31a354\",\n            \"C2\": \"#addd8e\",\n            \"C3\": \"#fdae6b\",\n            \"C4\": \"#fd8d3c\",\n            \"C5\": \"#e31a1c\",\n        }\n\n        def get_category(vmax):\n            if vmax &lt; 39:\n                return \"TD\"\n            elif vmax &lt; 74:\n                return \"TS\"\n            elif vmax &lt; 96:\n                return \"C1\"\n            elif vmax &lt; 111:\n                return \"C2\"\n            elif vmax &lt; 130:\n                return \"C3\"\n            elif vmax &lt; 157:\n                return \"C4\"\n            else:\n                return \"C5\"\n\n        dataset = tracks.TrackDataset(basin=basin, source=source)\n        storm = dataset.get_storm(name_or_tuple)\n\n        df = pd.DataFrame(\n            {\n                \"datetime\": storm.dict[\"time\"],\n                \"lat\": storm.dict[\"lat\"],\n                \"lon\": storm.dict[\"lon\"],\n                \"vmax\": storm.dict[\"vmax\"],\n                \"mslp\": storm.dict[\"mslp\"],\n                \"type\": storm.dict[\"type\"],\n                \"id\": storm.dict[\"id\"],\n                \"name\": storm.dict[\"name\"],\n            }\n        )\n\n        df[\"category\"] = df[\"vmax\"].apply(get_category)\n        df[\"color\"] = df[\"category\"].map(category_colors)\n        df[\"geometry\"] = [Point(xy) for xy in zip(df.lon, df.lat)]\n        gdf_points = gpd.GeoDataFrame(df, crs=\"EPSG:4326\")\n\n        segments = []\n        for i in range(len(gdf_points) - 1):\n            seg = LineString(\n                [gdf_points.geometry.iloc[i], gdf_points.geometry.iloc[i + 1]]\n            )\n            color = gdf_points.color.iloc[i]\n            segments.append({\"geometry\": seg, \"color\": color})\n\n        gdf_line = gpd.GeoDataFrame(segments, crs=\"EPSG:4326\")\n        for _, row in gdf_line.iterrows():\n            self.add_gdf(\n                gpd.GeoDataFrame([row], crs=\"EPSG:4326\"),\n                style={\"color\": row[\"color\"], \"weight\": 3, \"weight\": 8},\n                zoom_to_layer=False,\n            )\n\n        if zoom_to_layer:\n            self.fit_bounds(\n                gdf_points.total_bounds[[1, 0, 3, 2]].reshape(2, 2).tolist()\n            )\n\n    def get_storm_options(self, basin=\"north_atlantic\", source=\"hurdat\"):\n        from tropycal import tracks\n\n        dataset = tracks.TrackDataset(basin=basin, source=source)\n        storms = dataset.keys\n        years = [dataset.get_storm(storm).season for storm in storms]\n        return list(zip(storms, years))\n\n    def add_storm_wg(\n        self,\n        basin=\"north_atlantic\",\n        options=None,\n        source=\"hurdat\",\n        position=\"topright\",\n        legend=True,\n    ):\n        \"\"\"Adds a storm widget to the map.\n        Args:\n            basin (str): The basin of the storm. Defaults to 'north_atlantic'.\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\"].\n            source (str): The source of the storm data. Defaults to 'hurdat'.\n            position (str): The position of the widget on the map. Defaults to 'topright'.\n            legend (bool): Whether to show a legend. Defaults to True.\n        \"\"\"\n        import ipywidgets as widgets\n        import tropycal.tracks as tracks\n        from ipyleaflet import WidgetControl\n\n        if options is None:\n            options = [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\"]\n\n        widget_toggle = widgets.ToggleButton(\n            value=True,\n            icon=\"globe\",\n            tooltip=\"Show/Hide storm &amp; basemap\",\n            layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        storm_list = [\n            (\"Wilma\", 2005),\n            (\"Katrina\", 2005),\n            (\"Rita\", 2005),\n            (\"Sandy\", 2012),\n            (\"Hermine\", 2016),\n            (\"Matthew\", 2016),\n            (\"Otto\", 2016),\n            (\"Nate\", 2017),\n            (\"Harvey\", 2017),\n            (\"Irma\", 2017),\n            (\"Michael\", 2018),\n            (\"Dorian\", 2019),\n            (\"Lorenzo\", 2019),\n            (\"Laura\", 2020),\n            (\"Ida\", 2021),\n            (\"Ian\", 2022),\n            (\"Nicole\", 2022),\n            (\"Lee\", 2023),\n            (\"Ophelia\", 2023),\n            (\"Franklin\", 2023),\n            (\"Elsa\", 2021),\n            (\"Fiona\", 2022),\n            (\"Sally\", 2020),\n            (\"Teddy\", 2020),\n            (\"Zeta\", 2020),\n            (\"Helene\", 2024),\n        ]\n        storm_options = [(f\"{s[0]} ({s[1]})\", (s[0].lower(), s[1])) for s in storm_list]\n        default_value = storm_options[0][1]\n\n        storm_dropdown = widgets.Dropdown(\n            options=storm_options,\n            value=default_value,\n            description=\"Storm:\",\n            style={\"description_width\": \"initial\"},\n            layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        self._storm_dataset = tracks.TrackDataset(basin=basin, source=source)\n        self._current_storm = None\n\n        def on_storm_change(change):\n            if change[\"type\"] == \"change\" and change[\"name\"] == \"value\":\n                storm_name, storm_year = change[\"new\"]\n                self.layers = self.layers[:3]\n                if hasattr(self, \"_storm_layer\") and self._storm_layer in self.layers:\n                    self.remove_layer(self._storm_layer)\n                self._storm_layer = self.add_tropycal_storm(\n                    (storm_name, storm_year), basin=basin, source=source\n                )\n\n        storm_dropdown.observe(on_storm_change, names=\"value\")\n\n        controls_box = widgets.VBox([storm_dropdown])\n        controls_box.layout.display = \"flex\" if widget_toggle.value else \"none\"\n\n        widget_control = WidgetControl(\n            widget=widgets.VBox([widget_toggle, controls_box]), position=position\n        )\n        self.add(widget_control)\n\n        def toggle_controls(change):\n            controls_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n        widget_toggle.observe(toggle_controls, names=\"value\")\n\n        if legend:\n            import ipywidgets as widgets\n            from ipyleaflet import WidgetControl\n\n            category_colors = {\n                \"TD\": \"#6baed6\",\n                \"TS\": \"#3182bd\",\n                \"Category 1\": \"#31a354\",\n                \"Category 2\": \"#addd8e\",\n                \"Category 3\": \"#fdae6b\",\n                \"Category 4\": \"#fd8d8c\",\n                \"Category 5\": \"#e31a1c\",\n            }\n\n            legend_items = []\n            for label, color in category_colors.items():\n                legend_items.append(\n                    f\"&lt;div style='margin-bottom:2px;'&gt;&lt;span style='display:inline-block;width:12px;height:12px;background:{color};margin-right:6px;'&gt;&lt;/span&gt;{label}&lt;/div&gt;\"\n                )\n\n            legend_html = widgets.HTML(\n                value=f\"&lt;div style='padding:4px 8px;font-size:13px;line-height:1.4;'&gt;&lt;b&gt;Storm&lt;br&gt;Categories&lt;/b&gt;&lt;hr style='margin:4px 0;'/&gt;\"\n                + \"\".join(legend_items)\n                + \"&lt;/div&gt;\"\n            )\n\n            toggle_legend_btn = widgets.ToggleButton(\n                value=True,\n                icon=\"list\",\n                tooltip=\"Show/Hide legend\",\n                layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n            )\n\n            legend_box = widgets.VBox([toggle_legend_btn, legend_html])\n\n            def toggle_legend_display(change):\n                legend_html.layout.display = \"block\" if change[\"new\"] else \"none\"\n\n            toggle_legend_btn.observe(toggle_legend_display, names=\"value\")\n\n            legend_control = WidgetControl(widget=legend_box, position=\"bottomright\")\n            self.add(legend_control)\n\n    def add_wms_layer(\n        self,\n        url,\n        layers,\n        format=\"image/png\",\n        transparent=True,\n        **kwargs,\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        from ipywidgets import DatePicker, Layout\n        from datetime import date\n\n        layers = ipyleaflet.WMSLayer(\n            url=url, layers=layers, format=format, transparent=transparent, **kwargs\n        )\n\n    def add_time_wms_layer(\n        self,\n        url=\"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\",\n        layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\",\n        time=\"2020-07-05\",\n        format=\"image/png\",\n        transparent=True,\n        attribution=\"NASA GIBS\",\n        name=\"Time WMS Layer\",\n        legend=True,\n        custom_legend=None,\n        position=\"bottomleft\",\n    ):\n        \"\"\"Adds a WMS layer with time control to the map.\n        Args:\n            url (str): The WMS service URL. Defaults to \"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\".\n            layers (str): The layers to display. Defaults to \"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\".\n            time (str): The time parameter for the WMS request. Defaults to \"2020-07-05\".\n            format (str): The image format. Defaults to \"image/png\".\n            transparent (bool): Whether the layer is transparent. Defaults to True.\n            attribution (str): Attribution text. Defaults to \"NASA GIBS\".\n            name (str): Name of the layer. Defaults to \"Time WMS Layer\".\n            legend (bool): Whether to show a legend. Defaults to True.\n            custom_legend (dict, optional): Custom legend items. Defaults to None.\n            position (str): Position of the legend on the map. Defaults to \"bottomleft\".\n        \"\"\"\n        from ipyleaflet import WMSLayer, WidgetControl\n        import ipywidgets as widgets\n        from datetime import date\n\n        time_url = f\"{url}?TIME={time}\"\n\n        wms_layer = WMSLayer(\n            url=time_url,\n            layers=layers,\n            format=format,\n            transparent=transparent,\n            attribution=attribution,\n            name=name,\n        )\n        self.add_layer(wms_layer)\n\n        date_picker = widgets.DatePicker(\n            description=\"Select Date\",\n            value=date.fromisoformat(time),\n            layout=widgets.Layout(width=\"200px\"),\n        )\n\n        def update_time(change):\n            if change[\"new\"]:\n                new_date = change[\"new\"].isoformat()\n                wms_layer.url = f\"{url}?TIME={new_date}\"\n\n        date_picker.observe(update_time, names=\"value\")\n\n        date_control = WidgetControl(widget=date_picker, position=\"topright\")\n        self.add_control(date_control)\n\n        if legend:\n            built_in_legends = {\n                \"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\": {\n                    \"&lt; -10\u00b0C\": \"#000080\",\n                    \"0\u00b0C\": \"#0000FF\",\n                    \"10\u00b0C\": \"#00FFFF\",\n                    \"20\u00b0C\": \"#00FF00\",\n                    \"30\u00b0C\": \"#FFFF00\",\n                    \"40\u00b0C\": \"#FFA500\",\n                    \"\u2265 50\u00b0C\": \"#FF0000\",\n                }\n            }\n\n            legend_items = custom_legend or built_in_legends.get(layers)\n\n            if legend_items:\n                title_html = (\n                    \"&lt;div style='text-align:center; font-size:12px; font-weight:bold;'&gt;\"\n                    f\"{layers.replace('_', ' ')}\".replace(\n                        \"MODIS Aqua L3\", \"MODIS Aqua L3&lt;br&gt;Land Surface Temp\"\n                    )\n                    + \"&lt;/div&gt;&lt;hr style='margin:2px 0;'&gt;\"\n                )\n\n                legend_html = widgets.HTML()\n                legend_html.value = (\n                    f\"&lt;div style='font-size:12px; line-height:1.4em; max-width:160px;'&gt;\"\n                    f\"{title_html}\"\n                )\n\n                for label, color in legend_items.items():\n                    legend_html.value += (\n                        f\"&lt;div style='display:flex; align-items:center; justify-content:center; margin:2px 0;'&gt;\"\n                        f\"&lt;span style='display:inline-block;width:12px;height:12px;\"\n                        f\"background:{color};margin-right:6px;border:1px solid #ccc;'&gt;&lt;/span&gt;\"\n                        f\"&lt;span style='text-align:center;'&gt;{label}&lt;/span&gt;\"\n                        f\"&lt;/div&gt;\"\n                    )\n                legend_html.value += \"&lt;/div&gt;\"\n\n                legend_box = widgets.VBox([legend_html])\n                legend_box.layout.display = \"flex\"\n                legend_box.layout.padding = \"2px 6px\"\n\n                toggle_button = widgets.ToggleButton(\n                    value=True,\n                    tooltip=\"Toggle Legend\",\n                    icon=\"list\",\n                    layout=widgets.Layout(width=\"26px\", height=\"26px\", padding=\"0\"),\n                )\n\n                def toggle_visibility(change):\n                    legend_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n                toggle_button.observe(toggle_visibility, names=\"value\")\n\n                widget = widgets.VBox([toggle_button, legend_box])\n                control = WidgetControl(widget=widget, position=position)\n                self.add_control(control)\n            else:\n                print(f\"No legend available for layer: {layers}\")\n\n        return wms_layer\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style={\"color\": \"yellow\", \"fillOpacity\": 0.5},\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n            zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n            hover_style (dict, optional): Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.\n        \"\"\"\n        import json\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n            gdf = gpd.GeoDataFrame.from_features(geojson[\"features\"], crs=\"EPSG:4326\")\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, filepath, **kwargs):\n        \"\"\"Adds a raster layer to the map.\n        Args:\n            filepath (str): The file path to the raster file.\n            **kwargs: Additional keyword arguments for the ipyleaflet.TileLayer layer.\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n        self.add(overlay)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap.Mapnik')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"Esri.WorldImagery\".</p> <code>'OpenStreetMap.Mapnik'</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap.Mapnik\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style={'color': 'yellow', 'fillOpacity': 0.5}, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Zoom in to the layer on the map. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.</p> <code>{'color': 'yellow', 'fillOpacity': 0.5}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style={\"color\": \"yellow\", \"fillOpacity\": 0.5},\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n        zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n        hover_style (dict, optional): Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.\n    \"\"\"\n    import json\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n        gdf = gpd.GeoDataFrame.from_features(geojson[\"features\"], crs=\"EPSG:4326\")\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_image","title":"<code>add_image(self, image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>geogo/geogo.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_raster","title":"<code>add_raster(self, filepath, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The file path to the raster file.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.TileLayer layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_raster(self, filepath, **kwargs):\n    \"\"\"Adds a raster layer to the map.\n    Args:\n        filepath (str): The file path to the raster file.\n        **kwargs: Additional keyword arguments for the ipyleaflet.TileLayer layer.\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(filepath)\n    tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_storm_wg","title":"<code>add_storm_wg(self, basin='north_atlantic', options=None, source='hurdat', position='topright', legend=True)</code>","text":"<p>Adds a storm widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basin</code> <code>str</code> <p>The basin of the storm. Defaults to 'north_atlantic'.</p> <code>'north_atlantic'</code> <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\"].</p> <code>None</code> <code>source</code> <code>str</code> <p>The source of the storm data. Defaults to 'hurdat'.</p> <code>'hurdat'</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to 'topright'.</p> <code>'topright'</code> <code>legend</code> <code>bool</code> <p>Whether to show a legend. Defaults to True.</p> <code>True</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_storm_wg(\n    self,\n    basin=\"north_atlantic\",\n    options=None,\n    source=\"hurdat\",\n    position=\"topright\",\n    legend=True,\n):\n    \"\"\"Adds a storm widget to the map.\n    Args:\n        basin (str): The basin of the storm. Defaults to 'north_atlantic'.\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\"].\n        source (str): The source of the storm data. Defaults to 'hurdat'.\n        position (str): The position of the widget on the map. Defaults to 'topright'.\n        legend (bool): Whether to show a legend. Defaults to True.\n    \"\"\"\n    import ipywidgets as widgets\n    import tropycal.tracks as tracks\n    from ipyleaflet import WidgetControl\n\n    if options is None:\n        options = [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\"]\n\n    widget_toggle = widgets.ToggleButton(\n        value=True,\n        icon=\"globe\",\n        tooltip=\"Show/Hide storm &amp; basemap\",\n        layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    storm_list = [\n        (\"Wilma\", 2005),\n        (\"Katrina\", 2005),\n        (\"Rita\", 2005),\n        (\"Sandy\", 2012),\n        (\"Hermine\", 2016),\n        (\"Matthew\", 2016),\n        (\"Otto\", 2016),\n        (\"Nate\", 2017),\n        (\"Harvey\", 2017),\n        (\"Irma\", 2017),\n        (\"Michael\", 2018),\n        (\"Dorian\", 2019),\n        (\"Lorenzo\", 2019),\n        (\"Laura\", 2020),\n        (\"Ida\", 2021),\n        (\"Ian\", 2022),\n        (\"Nicole\", 2022),\n        (\"Lee\", 2023),\n        (\"Ophelia\", 2023),\n        (\"Franklin\", 2023),\n        (\"Elsa\", 2021),\n        (\"Fiona\", 2022),\n        (\"Sally\", 2020),\n        (\"Teddy\", 2020),\n        (\"Zeta\", 2020),\n        (\"Helene\", 2024),\n    ]\n    storm_options = [(f\"{s[0]} ({s[1]})\", (s[0].lower(), s[1])) for s in storm_list]\n    default_value = storm_options[0][1]\n\n    storm_dropdown = widgets.Dropdown(\n        options=storm_options,\n        value=default_value,\n        description=\"Storm:\",\n        style={\"description_width\": \"initial\"},\n        layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    self._storm_dataset = tracks.TrackDataset(basin=basin, source=source)\n    self._current_storm = None\n\n    def on_storm_change(change):\n        if change[\"type\"] == \"change\" and change[\"name\"] == \"value\":\n            storm_name, storm_year = change[\"new\"]\n            self.layers = self.layers[:3]\n            if hasattr(self, \"_storm_layer\") and self._storm_layer in self.layers:\n                self.remove_layer(self._storm_layer)\n            self._storm_layer = self.add_tropycal_storm(\n                (storm_name, storm_year), basin=basin, source=source\n            )\n\n    storm_dropdown.observe(on_storm_change, names=\"value\")\n\n    controls_box = widgets.VBox([storm_dropdown])\n    controls_box.layout.display = \"flex\" if widget_toggle.value else \"none\"\n\n    widget_control = WidgetControl(\n        widget=widgets.VBox([widget_toggle, controls_box]), position=position\n    )\n    self.add(widget_control)\n\n    def toggle_controls(change):\n        controls_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n    widget_toggle.observe(toggle_controls, names=\"value\")\n\n    if legend:\n        import ipywidgets as widgets\n        from ipyleaflet import WidgetControl\n\n        category_colors = {\n            \"TD\": \"#6baed6\",\n            \"TS\": \"#3182bd\",\n            \"Category 1\": \"#31a354\",\n            \"Category 2\": \"#addd8e\",\n            \"Category 3\": \"#fdae6b\",\n            \"Category 4\": \"#fd8d8c\",\n            \"Category 5\": \"#e31a1c\",\n        }\n\n        legend_items = []\n        for label, color in category_colors.items():\n            legend_items.append(\n                f\"&lt;div style='margin-bottom:2px;'&gt;&lt;span style='display:inline-block;width:12px;height:12px;background:{color};margin-right:6px;'&gt;&lt;/span&gt;{label}&lt;/div&gt;\"\n            )\n\n        legend_html = widgets.HTML(\n            value=f\"&lt;div style='padding:4px 8px;font-size:13px;line-height:1.4;'&gt;&lt;b&gt;Storm&lt;br&gt;Categories&lt;/b&gt;&lt;hr style='margin:4px 0;'/&gt;\"\n            + \"\".join(legend_items)\n            + \"&lt;/div&gt;\"\n        )\n\n        toggle_legend_btn = widgets.ToggleButton(\n            value=True,\n            icon=\"list\",\n            tooltip=\"Show/Hide legend\",\n            layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        legend_box = widgets.VBox([toggle_legend_btn, legend_html])\n\n        def toggle_legend_display(change):\n            legend_html.layout.display = \"block\" if change[\"new\"] else \"none\"\n\n        toggle_legend_btn.observe(toggle_legend_display, names=\"value\")\n\n        legend_control = WidgetControl(widget=legend_box, position=\"bottomright\")\n        self.add(legend_control)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_time_wms_layer","title":"<code>add_time_wms_layer(self, url='https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi', layers='MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day', time='2020-07-05', format='image/png', transparent=True, attribution='NASA GIBS', name='Time WMS Layer', legend=True, custom_legend=None, position='bottomleft')</code>","text":"<p>Adds a WMS layer with time control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL. Defaults to \"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\".</p> <code>'https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi'</code> <code>layers</code> <code>str</code> <p>The layers to display. Defaults to \"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\".</p> <code>'MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day'</code> <code>time</code> <code>str</code> <p>The time parameter for the WMS request. Defaults to \"2020-07-05\".</p> <code>'2020-07-05'</code> <code>format</code> <code>str</code> <p>The image format. Defaults to \"image/png\".</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether the layer is transparent. Defaults to True.</p> <code>True</code> <code>attribution</code> <code>str</code> <p>Attribution text. Defaults to \"NASA GIBS\".</p> <code>'NASA GIBS'</code> <code>name</code> <code>str</code> <p>Name of the layer. Defaults to \"Time WMS Layer\".</p> <code>'Time WMS Layer'</code> <code>legend</code> <code>bool</code> <p>Whether to show a legend. Defaults to True.</p> <code>True</code> <code>custom_legend</code> <code>dict</code> <p>Custom legend items. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>Position of the legend on the map. Defaults to \"bottomleft\".</p> <code>'bottomleft'</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_time_wms_layer(\n    self,\n    url=\"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\",\n    layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\",\n    time=\"2020-07-05\",\n    format=\"image/png\",\n    transparent=True,\n    attribution=\"NASA GIBS\",\n    name=\"Time WMS Layer\",\n    legend=True,\n    custom_legend=None,\n    position=\"bottomleft\",\n):\n    \"\"\"Adds a WMS layer with time control to the map.\n    Args:\n        url (str): The WMS service URL. Defaults to \"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\".\n        layers (str): The layers to display. Defaults to \"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\".\n        time (str): The time parameter for the WMS request. Defaults to \"2020-07-05\".\n        format (str): The image format. Defaults to \"image/png\".\n        transparent (bool): Whether the layer is transparent. Defaults to True.\n        attribution (str): Attribution text. Defaults to \"NASA GIBS\".\n        name (str): Name of the layer. Defaults to \"Time WMS Layer\".\n        legend (bool): Whether to show a legend. Defaults to True.\n        custom_legend (dict, optional): Custom legend items. Defaults to None.\n        position (str): Position of the legend on the map. Defaults to \"bottomleft\".\n    \"\"\"\n    from ipyleaflet import WMSLayer, WidgetControl\n    import ipywidgets as widgets\n    from datetime import date\n\n    time_url = f\"{url}?TIME={time}\"\n\n    wms_layer = WMSLayer(\n        url=time_url,\n        layers=layers,\n        format=format,\n        transparent=transparent,\n        attribution=attribution,\n        name=name,\n    )\n    self.add_layer(wms_layer)\n\n    date_picker = widgets.DatePicker(\n        description=\"Select Date\",\n        value=date.fromisoformat(time),\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    def update_time(change):\n        if change[\"new\"]:\n            new_date = change[\"new\"].isoformat()\n            wms_layer.url = f\"{url}?TIME={new_date}\"\n\n    date_picker.observe(update_time, names=\"value\")\n\n    date_control = WidgetControl(widget=date_picker, position=\"topright\")\n    self.add_control(date_control)\n\n    if legend:\n        built_in_legends = {\n            \"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\": {\n                \"&lt; -10\u00b0C\": \"#000080\",\n                \"0\u00b0C\": \"#0000FF\",\n                \"10\u00b0C\": \"#00FFFF\",\n                \"20\u00b0C\": \"#00FF00\",\n                \"30\u00b0C\": \"#FFFF00\",\n                \"40\u00b0C\": \"#FFA500\",\n                \"\u2265 50\u00b0C\": \"#FF0000\",\n            }\n        }\n\n        legend_items = custom_legend or built_in_legends.get(layers)\n\n        if legend_items:\n            title_html = (\n                \"&lt;div style='text-align:center; font-size:12px; font-weight:bold;'&gt;\"\n                f\"{layers.replace('_', ' ')}\".replace(\n                    \"MODIS Aqua L3\", \"MODIS Aqua L3&lt;br&gt;Land Surface Temp\"\n                )\n                + \"&lt;/div&gt;&lt;hr style='margin:2px 0;'&gt;\"\n            )\n\n            legend_html = widgets.HTML()\n            legend_html.value = (\n                f\"&lt;div style='font-size:12px; line-height:1.4em; max-width:160px;'&gt;\"\n                f\"{title_html}\"\n            )\n\n            for label, color in legend_items.items():\n                legend_html.value += (\n                    f\"&lt;div style='display:flex; align-items:center; justify-content:center; margin:2px 0;'&gt;\"\n                    f\"&lt;span style='display:inline-block;width:12px;height:12px;\"\n                    f\"background:{color};margin-right:6px;border:1px solid #ccc;'&gt;&lt;/span&gt;\"\n                    f\"&lt;span style='text-align:center;'&gt;{label}&lt;/span&gt;\"\n                    f\"&lt;/div&gt;\"\n                )\n            legend_html.value += \"&lt;/div&gt;\"\n\n            legend_box = widgets.VBox([legend_html])\n            legend_box.layout.display = \"flex\"\n            legend_box.layout.padding = \"2px 6px\"\n\n            toggle_button = widgets.ToggleButton(\n                value=True,\n                tooltip=\"Toggle Legend\",\n                icon=\"list\",\n                layout=widgets.Layout(width=\"26px\", height=\"26px\", padding=\"0\"),\n            )\n\n            def toggle_visibility(change):\n                legend_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n            toggle_button.observe(toggle_visibility, names=\"value\")\n\n            widget = widgets.VBox([toggle_button, legend_box])\n            control = WidgetControl(widget=widget, position=position)\n            self.add_control(control)\n        else:\n            print(f\"No legend available for layer: {layers}\")\n\n    return wms_layer\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_tropycal_storm","title":"<code>add_tropycal_storm(self, name_or_tuple, basin='north_atlantic', source='hurdat', zoom_to_layer=True)</code>","text":"<p>Adds a storm track to the map using Tropycal.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_tuple</code> <code>str or tuple</code> <p>The name of the storm or a tuple containing the name and year.</p> required <code>basin</code> <code>str</code> <p>The basin of the storm. Defaults to 'north_atlantic'.</p> <code>'north_atlantic'</code> <code>source</code> <code>str</code> <p>The source of the storm data. Defaults to 'hurdat'.</p> <code>'hurdat'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer after adding it. Defaults to True.</p> <code>True</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_tropycal_storm(\n    self,\n    name_or_tuple,\n    basin=\"north_atlantic\",\n    source=\"hurdat\",\n    zoom_to_layer=True,\n):\n    \"\"\"Adds a storm track to the map using Tropycal.\n    Args:\n        name_or_tuple (str or tuple): The name of the storm or a tuple containing the name and year.\n        basin (str, optional): The basin of the storm. Defaults to 'north_atlantic'.\n        source (str, optional): The source of the storm data. Defaults to 'hurdat'.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it. Defaults to True.\n    \"\"\"\n    import tropycal.tracks as tracks\n    import geopandas as gpd\n    from shapely.geometry import Point, LineString\n    import pandas as pd\n\n    category_colors = {\n        \"TD\": \"#6baed6\",\n        \"TS\": \"#3182bd\",\n        \"C1\": \"#31a354\",\n        \"C2\": \"#addd8e\",\n        \"C3\": \"#fdae6b\",\n        \"C4\": \"#fd8d3c\",\n        \"C5\": \"#e31a1c\",\n    }\n\n    def get_category(vmax):\n        if vmax &lt; 39:\n            return \"TD\"\n        elif vmax &lt; 74:\n            return \"TS\"\n        elif vmax &lt; 96:\n            return \"C1\"\n        elif vmax &lt; 111:\n            return \"C2\"\n        elif vmax &lt; 130:\n            return \"C3\"\n        elif vmax &lt; 157:\n            return \"C4\"\n        else:\n            return \"C5\"\n\n    dataset = tracks.TrackDataset(basin=basin, source=source)\n    storm = dataset.get_storm(name_or_tuple)\n\n    df = pd.DataFrame(\n        {\n            \"datetime\": storm.dict[\"time\"],\n            \"lat\": storm.dict[\"lat\"],\n            \"lon\": storm.dict[\"lon\"],\n            \"vmax\": storm.dict[\"vmax\"],\n            \"mslp\": storm.dict[\"mslp\"],\n            \"type\": storm.dict[\"type\"],\n            \"id\": storm.dict[\"id\"],\n            \"name\": storm.dict[\"name\"],\n        }\n    )\n\n    df[\"category\"] = df[\"vmax\"].apply(get_category)\n    df[\"color\"] = df[\"category\"].map(category_colors)\n    df[\"geometry\"] = [Point(xy) for xy in zip(df.lon, df.lat)]\n    gdf_points = gpd.GeoDataFrame(df, crs=\"EPSG:4326\")\n\n    segments = []\n    for i in range(len(gdf_points) - 1):\n        seg = LineString(\n            [gdf_points.geometry.iloc[i], gdf_points.geometry.iloc[i + 1]]\n        )\n        color = gdf_points.color.iloc[i]\n        segments.append({\"geometry\": seg, \"color\": color})\n\n    gdf_line = gpd.GeoDataFrame(segments, crs=\"EPSG:4326\")\n    for _, row in gdf_line.iterrows():\n        self.add_gdf(\n            gpd.GeoDataFrame([row], crs=\"EPSG:4326\"),\n            style={\"color\": row[\"color\"], \"weight\": 3, \"weight\": 8},\n            zoom_to_layer=False,\n        )\n\n    if zoom_to_layer:\n        self.fit_bounds(\n            gdf_points.total_bounds[[1, 0, 3, 2]].reshape(2, 2).tolist()\n        )\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>geogo/geogo.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_video","title":"<code>add_video(self, video, bounds=None, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_video(self, video, bounds=None, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_wms_layer(\n    self,\n    url,\n    layers,\n    format=\"image/png\",\n    transparent=True,\n    **kwargs,\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    from ipywidgets import DatePicker, Layout\n    from datetime import date\n\n    layers = ipyleaflet.WMSLayer(\n        url=url, layers=layers, format=format, transparent=transparent, **kwargs\n    )\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geogo, run this command in your terminal:</p> <pre><code>pip install geogo\n</code></pre> <p>This is the preferred method to install geogo, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geogo from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/jlhammel/geogo\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geogo in a project:</p> <pre><code>import geogo\n</code></pre>"},{"location":"examples/StormWMS/","title":"StormWMS","text":"<p>add_time_wms_layer allows you to use WMS data from NASA GIBS to analyse things such as precipitation, vegetation indices and population at the time of a hurricane. You can also change the date of the WMS layer by using the date widget at the top right of the map.</p> In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo <p>Air Temperature:</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(\n    layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\", time=\"2024-09-25\", name=\"NASA\"\n)\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(     layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\", time=\"2024-09-25\", name=\"NASA\" ) m In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(\n    layers=\"AIRS_L2_Temperature_500hPa_Day\", time=\"2024-09-25\", name=\"NASA\"\n)\nm.add_tropycal_storm((\"helene\", 2024))\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(     layers=\"AIRS_L2_Temperature_500hPa_Day\", time=\"2024-09-25\", name=\"NASA\" ) m.add_tropycal_storm((\"helene\", 2024)) m <p>Precipitation:</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\"\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\" <p>custom_legend allows the user to input their own legend for the NASA GIBS data.</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\ncustom_legend = {\n    \"0.0 - 0.2\": \"#edf8fb\",\n    \"0.2 - 0.5\": \"#b2e2e2\",\n    \"0.5 - 1.0\": \"#66c2a4\",\n    \"1.0 - 2.0\": \"#2ca25f\",\n    \"2.0 - 5.0\": \"006d2c\",\n    \"5.0 - 10.0\": \"#fd8d3c\",\n    \"&gt;10\": \"#bd0026\",\n}\nm.add_shp(\n    url,\n    zoom_to_layer=False,\n    name=\"U.S. States\",\n    style={\"color\": \"black\", \"fillOpacity\": 0},\n    hover_style={},\n)\nm.add_storm_wg()\nm.add_time_wms_layer(\n    layers=\"AMSRU2_Surface_Precipitation_Day\",\n    time=\"2024-09-25\",\n    name=\"NASA\",\n    custom_legend=custom_legend,\n)\nm\n</pre> m = geogo.Map() custom_legend = {     \"0.0 - 0.2\": \"#edf8fb\",     \"0.2 - 0.5\": \"#b2e2e2\",     \"0.5 - 1.0\": \"#66c2a4\",     \"1.0 - 2.0\": \"#2ca25f\",     \"2.0 - 5.0\": \"006d2c\",     \"5.0 - 10.0\": \"#fd8d3c\",     \"&gt;10\": \"#bd0026\", } m.add_shp(     url,     zoom_to_layer=False,     name=\"U.S. States\",     style={\"color\": \"black\", \"fillOpacity\": 0},     hover_style={}, ) m.add_storm_wg() m.add_time_wms_layer(     layers=\"AMSRU2_Surface_Precipitation_Day\",     time=\"2024-09-25\",     name=\"NASA\",     custom_legend=custom_legend, ) m <p>Vegetation Indices</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\ncustom_legend = {\n    \"Bare soil / snow\": \"#f7fcb9\",\n    \"Sparse Vegetation\": \"#addd8e\",\n    \"Moderate Vegetation\": \"#41ab5d\",\n    \"Dense vegetation\": \"#238b45\",\n    \"Very Dense Vegetation\": \"#005a32\",\n}\nm.add_time_wms_layer(\n    layers=\"MODIS_Aqua_L3_EVI_16Day\",\n    time=\"2024-10-20\",\n    name=\"NASA\",\n    custom_legend=custom_legend,\n)\nm.add_shp(\n    url,\n    zoom_to_layer=False,\n    name=\"U.S. States\",\n    style={\"color\": \"black\", \"fillOpacity\": 0},\n    hover_style={},\n)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() custom_legend = {     \"Bare soil / snow\": \"#f7fcb9\",     \"Sparse Vegetation\": \"#addd8e\",     \"Moderate Vegetation\": \"#41ab5d\",     \"Dense vegetation\": \"#238b45\",     \"Very Dense Vegetation\": \"#005a32\", } m.add_time_wms_layer(     layers=\"MODIS_Aqua_L3_EVI_16Day\",     time=\"2024-10-20\",     name=\"NASA\",     custom_legend=custom_legend, ) m.add_shp(     url,     zoom_to_layer=False,     name=\"U.S. States\",     style={\"color\": \"black\", \"fillOpacity\": 0},     hover_style={}, ) m.add_storm_wg() m"},{"location":"examples/StormWMS/#storm-wms-analysis","title":"Storm WMS Analysis\u00b6","text":""},{"location":"examples/storm/","title":"Storm","text":"In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo <p>add_storm_wg allows the user to switch between storms using a dropdown widget and a legend to indicate the hurricane category.</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_storm_wg() m <p>If the hurricane you wish to track is not in the dropdown widget you can still analyze it by using add_tropycal_storm. Just input the ((\"hurricane name\", \"year\")).</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_basemap()\nm.add_tropycal_storm((\"maria\", 2017))\nm\n</pre> m = geogo.Map() m.add_basemap() m.add_tropycal_storm((\"maria\", 2017)) m"},{"location":"examples/storm/#tropical-storm-analysis","title":"Tropical Storm Analysis\u00b6","text":""},{"location":"examples/stormriv/","title":"Stormriv","text":"<p>Geogo allows you to input raster, image and video data in order to help visualize hurricane impact.</p> In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo <p>Raster:</p> In\u00a0[\u00a0]: Copied! <pre>filename = \"https://github.com/opengeos/datasets/releases/download/raster/nlcd_2021_land_cover_30m.tif\"\n</pre> filename = \"https://github.com/opengeos/datasets/releases/download/raster/nlcd_2021_land_cover_30m.tif\" In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_raster(filename, colormap=\"accent\", name=\"demo\", opacity=0.5)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_raster(filename, colormap=\"accent\", name=\"demo\", opacity=0.5) m.add_storm_wg() m <p>Image:</p> In\u00a0[\u00a0]: Copied! <pre>imageurl = \"https://www.rmets.org/sites/default/files/2024-10/202409262200_g16_fd_geocolor_hurricane-helene-at-sunset_nolabels-hires.png\"\nbounds = (15.0, -100), (40, -60)\n</pre> imageurl = \"https://www.rmets.org/sites/default/files/2024-10/202409262200_g16_fd_geocolor_hurricane-helene-at-sunset_nolabels-hires.png\" bounds = (15.0, -100), (40, -60) In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_image(imageurl, name=\"image\", opacity=0.7, bounds=bounds)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_image(imageurl, name=\"image\", opacity=0.7, bounds=bounds) m.add_storm_wg() m"},{"location":"examples/stormriv/#raster-image-and-video-maps","title":"Raster, image, and video maps\u00b6","text":""}]}