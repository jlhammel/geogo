{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geogo","text":"<p>A python package for geospatial analysis and mapping hurricane tracks</p> <ul> <li>Free software: MIT License</li> <li>GitHub repo: https://github.com/jlhammel/geogo</li> <li> <p>Documentation: https://jlhammel.github.io/geogo</p> </li> <li> <p>Geogo is a Python package meant for climatologists to analyze hurricane data from HURDAT2. Geogo using ipyleaflet to create interactive maps for analysis. This package will allow you to use WMS, raster, geojson, image, and video files to further understand the impact of past hurricanes. Using interactive maps and hurricane track data from the Python package tropycal, the user can track the hurricane and analyze the landscape around the impacted areas.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements:","text":"<ul> <li>Install from PyPi folium geopandas ipyleaflet leafmap localtileserver mapclassify matplotlib numpy</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Process geospatial data</li> <li>Track past hurricanes impacting the Americas</li> <li>Analyse hurricanes using images, raster, video, WMS and geojson files</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p><pre><code>import geogo\nimport os\n</code></pre> - Install from GitHub   <pre><code>pip install git+https://github.com/jlhammel/geogo\n</code></pre></p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geogo.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geogo/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jlhammel/geogo/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geogo could always use more documentation, whether as part of the official geogo docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jlhammel/geogo/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geogo for local development.</p> <ol> <li> <p>Fork the geogo repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geogo.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geogo\n$ cd geogo/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geogo tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/jlhammel/geogo/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliummap/","title":"foliummap module","text":"<p>This module provides a custom Map class that extends the folium.Map class</p>"},{"location":"foliummap/#geogo.foliummap.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>geogo/foliummap.py</code> <pre><code>class Map(folium.Map):\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n        \"\"\"\n\n        url = eval(f\"folium.basemaps.{basemap}\").build_url()\n        layer = folium.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Add a GeoJSON layer to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n            zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n            hover_style (_type_, optional): Changes color when hover over place on map.. Defaults to None.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Add a shapefile to the map.\n\n        Args:\n            data (_type_): The file path to the shapefile.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Add a GeoDataFrame to the map.\n\n        Args:\n            gdf (_type_): The GeoDataFrame to add.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    # def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    #     \"\"\"Add split map to compare two maps.\n\n    #     Args:\n    #         left (str, optional): Map type on the left of the map. Defaults to 'openstreetmap'.\n    #         right (str, optional): Map type on the right of the map. Defaults to 'cartodbpositron'.\n    #     \"\"\"\n    #     layer_right = folium.TileLayer(left, **kwargs)\n    #     layer_left = folium.TileLayer(right, **kwargs)\n\n    #     sbs = folium.plugins.SideBySideLayers(\n    #         layer_left=layer_left, layer_right=layer_right\n    #     )\n\n    #     layer_left.add_to(self)\n    #     layer_right.add_to(self)\n    #     sbs.add_to(self)\n\n    # def add_raster(self, left, right, **kwargs):\n    #     \"\"\"Add raster data to maps.\n\n    #     Args:\n    #         left (_type_): Add raster data to the left of the map.\n    #         right (_type_):Add raster data to the right of the map.\n    #     \"\"\"\n    #     from localtileserver import TileClient, get_folium_tile_layer\n\n    #     right_layer = get_folium_tile_layer(right, **kwargs)\n    #     left_layer = get_folium_tile_layer(left, **kwargs)\n\n    #     sbs = folium.plugins.SideBySideLayers(\n    #         layer_left=left_layer, layer_right=right_layer\n    #     )\n\n    #     left_layer.add_to(self)\n    #     right_layer.add_to(self)\n    #     sbs.add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"Adds a split map to the map.\n\n        Args:\n            left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n            right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n        \"\"\"\n        from localtileserver import get_folium_tile_layer\n\n        if left.startswith(\"http\") or os.path.exists(left):\n            layer_left = get_folium_tile_layer(left, **kwargs)\n        else:\n            layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n        if right.startswith(\"http\") or os.path.exists(right):\n            layer_right = get_folium_tile_layer(right, **kwargs)\n        else:\n            layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n    \"\"\"\n\n    url = eval(f\"folium.basemaps.{basemap}\").build_url()\n    layer = folium.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Add a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>_type_</code> <p>The GeoDataFrame to add.</p> required Source code in <code>geogo/foliummap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Add a GeoDataFrame to the map.\n\n    Args:\n        gdf (_type_): The GeoDataFrame to add.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Add a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Zoom in to the layer on the map. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>_type_</code> <p>Changes color when hover over place on map.. Defaults to None.</p> <code>None</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Add a GeoJSON layer to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n        zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n        hover_style (_type_, optional): Changes color when hover over place on map.. Defaults to None.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control to the map.</p> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Add a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>The file path to the shapefile.</p> required Source code in <code>geogo/foliummap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Add a shapefile to the map.\n\n    Args:\n        data (_type_): The file path to the shapefile.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Adds a split map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The tile layer for the left side of the split map. Defaults to \"openstreetmap\".</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".</p> <code>'cartodbpositron'</code> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"Adds a split map to the map.\n\n    Args:\n        left (str, optional): The tile layer for the left side of the split map. Defaults to \"openstreetmap\".\n        right (str, optional): The tile layer for the right side of the split map. Defaults to \"cartodbpositron\".\n    \"\"\"\n    from localtileserver import get_folium_tile_layer\n\n    if left.startswith(\"http\") or os.path.exists(left):\n        layer_left = get_folium_tile_layer(left, **kwargs)\n    else:\n        layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n    if right.startswith(\"http\") or os.path.exists(right):\n        layer_right = get_folium_tile_layer(right, **kwargs)\n    else:\n        layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliummap/#geogo.foliummap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>geogo/foliummap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"geogo/","title":"geogo module","text":"<p>Main module.</p>"},{"location":"geogo/#geogo.geogo.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>geogo/geogo.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_tropycal_storm(\n        self,\n        name_or_tuple,\n        basin=\"north_atlantic\",\n        source=\"hurdat\",\n        zoom_to_layer=True,\n    ):\n        \"\"\"Adds a storm track to the map using Tropycal.\n        Args:\n            name_or_tuple (str or tuple): The name of the storm or a tuple containing the name and year.\n            basin (str, optional): The basin of the storm. Defaults to 'north_atlantic'.\n            source (str, optional): The source of the storm data. Defaults to 'hurdat'.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it. Defaults to True.\n        \"\"\"\n        import tropycal.tracks as tracks\n        import geopandas as gpd\n        from shapely.geometry import Point, LineString\n        import pandas as pd\n\n        category_colors = {\n            \"TD\": \"#6baed6\",\n            \"TS\": \"#3182bd\",\n            \"C1\": \"#31a354\",\n            \"C2\": \"#addd8e\",\n            \"C3\": \"#fdae6b\",\n            \"C4\": \"#fd8d3c\",\n            \"C5\": \"#e31a1c\",\n        }\n\n        def get_category(vmax):\n            if vmax &lt; 39:\n                return \"TD\"\n            elif vmax &lt; 74:\n                return \"TS\"\n            elif vmax &lt; 96:\n                return \"C1\"\n            elif vmax &lt; 111:\n                return \"C2\"\n            elif vmax &lt; 130:\n                return \"C3\"\n            elif vmax &lt; 157:\n                return \"C4\"\n            else:\n                return \"C5\"\n\n        dataset = tracks.TrackDataset(basin=basin, source=source)\n        storm = dataset.get_storm(name_or_tuple)\n\n        df = pd.DataFrame(\n            {\n                \"datetime\": storm.dict[\"time\"],\n                \"lat\": storm.dict[\"lat\"],\n                \"lon\": storm.dict[\"lon\"],\n                \"vmax\": storm.dict[\"vmax\"],\n                \"mslp\": storm.dict[\"mslp\"],\n                \"type\": storm.dict[\"type\"],\n                \"id\": storm.dict[\"id\"],\n                \"name\": storm.dict[\"name\"],\n            }\n        )\n\n        df[\"category\"] = df[\"vmax\"].apply(get_category)\n        df[\"color\"] = df[\"category\"].map(category_colors)\n        df[\"geometry\"] = [Point(xy) for xy in zip(df.lon, df.lat)]\n        gdf_points = gpd.GeoDataFrame(df, crs=\"EPSG:4326\")\n\n        segments = []\n        for i in range(len(gdf_points) - 1):\n            seg = LineString(\n                [gdf_points.geometry.iloc[i], gdf_points.geometry.iloc[i + 1]]\n            )\n            color = gdf_points.color.iloc[i]\n            segments.append({\"geometry\": seg, \"color\": color})\n\n        gdf_line = gpd.GeoDataFrame(segments, crs=\"EPSG:4326\")\n        for _, row in gdf_line.iterrows():\n            self.add_gdf(\n                gpd.GeoDataFrame([row], crs=\"EPSG:4326\"),\n                style={\"color\": row[\"color\"], \"weight\": 3},\n                zoom_to_layer=False,\n            )\n\n        if zoom_to_layer:\n            self.fit_bounds(\n                gdf_points.total_bounds[[1, 0, 3, 2]].reshape(2, 2).tolist()\n            )\n\n    def get_storm_options(self, basin=\"north_atlantic\", source=\"hurdat\"):\n        from tropycal import tracks\n\n        dataset = tracks.TrackDataset(basin=basin, source=source)\n        storms = dataset.keys\n        years = [dataset.get_storm(storm).season for storm in storms]\n        return list(zip(storms, years))  # [(storm_name, year), ...]\n\n    def add_storm_wg(\n        self,\n        basin=\"north_atlantic\",\n        options=None,\n        source=\"hurdat\",\n        position=\"topright\",\n        legend=True,\n    ):\n        \"\"\"Adds a storm widget to the map.\n        Args:\n            basin (str): The basin of the storm. Defaults to \"north_atlantic\".\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n            source (str): The source of the storm data. Defaults to \"hurdat\".\n            position (str): The position of the widget on the map. Defaults to \"topright\".\n            legend (bool): Whether to show a legend for storm categories. Defaults to True.\n        \"\"\"\n        import ipywidgets as widgets\n        import tropycal.tracks as tracks\n        from ipyleaflet import LegendControl, WidgetControl\n\n        if options is None:\n            options = [\"OpenStreetMap\", \"OpenTopoMap\", \"Esri.WorldImagery\"]\n\n        toggle_button = widgets.ToggleButton(\n            value=True,\n            icon=\"globe\",\n            tooltip=\"Show/Hide storm &amp; basemap\",\n            layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        basemap_dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        def on_basemap_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        basemap_dropdown.observe(on_basemap_change, names=\"value\")\n\n        storm_list = [\n            (\"Wilma\", 2005),\n            (\"Katrina\", 2005),\n            (\"Rita\", 2005),\n            (\"Sandy\", 2012),\n            (\"Gert\", 2016),\n            (\"Hermine\", 2016),\n            (\"Matthew\", 2016),\n            (\"Otto\", 2016),\n            (\"Patricia\", 2015),\n            (\"Nate\", 2017),\n            (\"Harvey\", 2017),\n            (\"Irma\", 2017),\n            (\"Michael\", 2018),\n            (\"Dorian\", 2019),\n            (\"Lorenzo\", 2019),\n            (\"Laura\", 2020),\n            (\"Ida\", 2021),\n            (\"Ian\", 2022),\n            (\"Nicole\", 2022),\n            (\"Lee\", 2023),\n            (\"Ophelia\", 2023),\n            (\"Franklin\", 2023),\n            (\"Elsa\", 2021),\n            (\"Fiona\", 2022),\n            (\"Sally\", 2020),\n            (\"Teddy\", 2020),\n            (\"Zeta\", 2020),\n            (\"Helene\", 2024),\n        ]\n        storm_options = [(f\"{s[0]} ({s[1]})\", (s[0].lower(), s[1])) for s in storm_list]\n        default_value = storm_options[0][1]\n\n        storm_dropdown = widgets.Dropdown(\n            options=storm_options,\n            value=default_value,\n            description=\"Storm:\",\n            style={\"description_width\": \"initial\"},\n            layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        self._storm_dataset = tracks.TrackDataset(basin=basin, source=source)\n        self._current_storm = None\n\n        def on_storm_change(change):\n            if change[\"type\"] == \"change\" and change[\"name\"] == \"value\":\n                storm_name, storm_year = change[\"new\"]\n                self.layers = self.layers[:3]\n                if hasattr(self, \"_storm_layer\") and self._storm_layer in self.layers:\n                    self.remove_layer(self._storm_layer)\n                self._storm_layer = self.add_tropycal_storm(\n                    (storm_name, storm_year), basin=basin, source=source\n                )\n\n        storm_dropdown.observe(on_storm_change, names=\"value\")\n\n        controls_box = widgets.VBox([basemap_dropdown, storm_dropdown])\n\n        def toggle_visibility(change):\n            controls_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n        toggle_button.observe(toggle_visibility, names=\"value\")\n\n        controls_box.layout.display = \"flex\" if toggle_button.value else \"none\"\n\n        unified_widget = widgets.VBox([toggle_button, controls_box])\n        control = WidgetControl(widget=unified_widget, position=position)\n        self.add(control)\n\n        if legend:\n            category_colors = {\n                \"TD\": \"#6baed6\",\n                \"TS\": \"#3182bd\",\n                \"Category 1\": \"#31a354\",\n                \"Category 2\": \"#addd8e\",\n                \"Category 3\": \"#fdae6b\",\n                \"Category 4\": \"#fd8d3c\",\n                \"Category 5\": \"#e31a1c\",\n            }\n            legend_control = LegendControl(\n                legend=category_colors, title=\"Storm Categories\", position=\"bottomright\"\n            )\n            self.add_control(legend_control)\n\n    def add_wms_layer(\n        self,\n        url,\n        layers,\n        format=\"image/png\",\n        transparent=True,\n        **kwargs,\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        from ipywidgets import DatePicker, Layout\n        from datetime import date\n\n        layers = ipyleaflet.WMSLayer(\n            url=url, layers=layers, format=format, transparent=transparent, **kwargs\n        )\n\n    def add_time_wms_layer(\n        self,\n        url=\"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\",\n        layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\",\n        time=\"2020-07-05\",\n        format=\"image/png\",\n        transparent=True,\n        attribution=\"NASA GIBS\",\n        name=\"Time WMS Layer\",\n    ):\n        \"\"\"Adds a time-enabled WMS layer to the map.\n\n        Args:\n            m (Map): ipyleaflet Map instance.\n            url (str): WMS service URL (GIBS or compatible).\n            layers (str): Name of the WMS layer.\n            time (str): Date in 'YYYY-MM-DD' format.\n            format (str): MIME type of the image layer.\n            transparent (bool): If background should be transparent.\n            attribution (str): Attribution text.\n            name (str): Display name for the layer.\n\n        Returns:\n            WMSLayer: The added WMS layer.\n        \"\"\"\n        from ipyleaflet import WMSLayer\n\n        time_url = f\"{url}?TIME={time}\"\n\n        wms_layer = WMSLayer(\n            url=time_url,\n            layers=layers,\n            format=format,\n            transparent=transparent,\n            attribution=attribution,\n            name=name,\n        )\n\n        self.add_layer(wms_layer)\n        return wms_layer\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style={\"color\": \"yellow\", \"fillOpacity\": 0.5},\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n            zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n            hover_style (dict, optional): Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.\n        \"\"\"\n        import json\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n            gdf = gpd.GeoDataFrame.from_features(geojson[\"features\"], crs=\"EPSG:4326\")\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, filepath, **kwargs):\n        \"\"\"Adds a raster layer to the map.\n        Args:\n            filepath (str): The file path to the raster file.\n            **kwargs: Additional keyword arguments for the ipyleaflet.TileLayer layer.\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    # def add_split_map(self, left_date, right_date, **kwargs):\n    #     \"\"\"Adds a split map to the map.\n\n    #     Args:\n    #         left_layer (ipyleaflet.Layer): The layer for the left side of the split map.\n    #         right_layer (ipyleaflet.Layer): The layer for the right side of the split map.\n    #         **kwargs: Additional keyword arguments for the ipyleaflet.SplitMapControl layer.\n    #     \"\"\"\n    #     from ipyleaflet import TileLayer, SplitMapControl\n\n    #     left_layer = TileLayer(\n    #         url=f\"https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Aqua_L3_EVI_16Day/default/{left_date}/GoogleMapsCompatible_Level9/{{z}}/{{y}}/{{x}}.jpg\",\n    #         layers='MODIS_Aqua_L3_EVI_16Day',\n    #         format=\"image/png\",\n    #         transparent=True,\n    #     )\n\n    #     right_layer = TileLayer(\n    #         url=f\"https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Aqua_L3_EVI_16Day/default/{right_date}/GoogleMapsCompatible_Level9/{{z}}/{{y}}/{{x}}.jpg\",\n    #         layers='MODIS_Aqua_L3_EVI_16Day',\n    #         format=\"image/png\",\n    #         transparent=True,\n    #     )\n    #     print(left_layer.url)\n\n    #     print(right_layer.url)\n    #     control = SplitMapControl(\n    #         left_layer=left_layer, right_layer=right_layer, **kwargs\n    #     )\n    #     self.add_control(control)\n\n    #     import ipywidgets as widgets\n    #     from datetime import date\n\n    #     left_date_picker = widgets.DatePicker(\n    #         description=\"Left Date\",\n    #         value=date.fromisoformat(left_date),\n    #         layout=widgets.Layout(width=\"200px\"),\n    #     )\n\n    #     right_date_picker = widgets.DatePicker(\n    #         description=\"Right Date\",\n    #         value=date.fromisoformat(right_date),\n    #         layout=widgets.Layout(width=\"200px\"),\n    #     )\n\n    #     toggle = widgets.ToggleButton(\n    #         value=True,\n    #         icon=\"globe\",\n    #         tooltip=\"Show/Hide storm selector\",\n    #         layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n    #     )\n    #     widget_box = widgets.HBox([toggle, left_date_picker, right_date_picker])\n\n    #     def on_date_change(change):\n    #         if change[\"name\"] == \"value\" and change[\"new\"] is not None:\n    #             new_left_date = left_date_picker.value.isoformat()\n    #             new_right_date = right_date_picker.value.isoformat()\n\n    #             left_layer.url = (\n    #                 f\"https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Aqua_L3_EVI_16Day/default/\"\n    #                 f\"{new_left_date}/GoogleMapsCompatible_Level9/{{z}}/{{y}}/{{x}}.jpg\"\n    #             )\n\n    #             right_layer.url = (\n    #                 f\"https://map1.vis.earthdata.nasa.gov/wmts-webmerc/MODIS_Aqua_L3_EVI_16Day/default/\"\n    #                 f\"{new_right_date}/GoogleMapsCompatible_Level9/{{z}}/{{y}}/{{x}}.jpg\"\n    #     )\n\n    #     def on_toggle(change):\n    #         if change[\"name\"] == \"value\" and change[\"new\"]:\n    #             left_date_picker.layout.display = \"flex\"\n    #             right_date_picker.layout.display = \"flex\"\n    #         else:\n    #             left_date_picker.layout.display = \"none\"\n    #             right_date_picker.layout.display = \"none\"\n\n    #     toggle.observe(on_toggle)\n\n    #     left_date_picker.observe(on_date_change)\n    #     right_date_picker.observe(on_date_change)\n\n    #     widget_box = widgets.HBox([left_date_picker, right_date_picker])\n    #     self.add_widget(widget_box, position=\"topright\")\n\n    # def add_basemap_gui(self, options=None, position=\"topright\"):\n    #     \"\"\"Adds a graphical user interface (GUI) for selecting basemaps.\n\n    #     Args:\n    #         options (list, optional): A list of basemap options to display in the dropdown.\n    #             Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n    #         position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    #     Behavior:\n    #         - A toggle button is used to show or hide the dropdown and close button.\n    #         - The dropdown allows users to select a basemap from the provided options.\n    #         - The close button removes the widget from the map.\n\n    #     Event Handlers:\n    #         - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n    #         - `on_button_click`: Closes and removes the widget from the map.\n    #         - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n    #     \"\"\"\n    #     if options is None:\n    #         options = [\n    #             \"OpenStreetMap\",\n    #             \"OpenTopoMap\",\n    #             \"Esri.WorldImagery\",\n    #         ]\n    #     toggle = ipywidgets.ToggleButton(\n    #         value=True,\n    #         button_style=\"\",\n    #         tooltip=\"Click me\",\n    #         icon=\"map\",\n    #     )\n    #     toggle.layout = ipywidgets.Layout(width=\"38px\", height=\"38px\")\n\n    #     dropdown = ipywidgets.Dropdown(\n    #         options=options,\n    #         value=options[0],\n    #         description=\"Basemap:\",\n    #         style={\"description_width\": \"initial\"},\n    #     )\n\n    #     dropdown.layout = ipywidgets.Layout(width=\"250px\", height=\"38px\")\n\n    #     button = ipywidgets.Button(\n    #         icon=\"times\",\n    #     )\n    #     button.layout = ipywidgets.Layout(width=\"38px\", height=\"38px\")\n\n    #     hbox = ipywidgets.HBox([toggle, dropdown, button])\n\n    #     def on_toggle_change(change):\n    #         if change[\"new\"]:\n    #             hbox.children = [toggle, dropdown, button]\n    #         else:\n    #             hbox.children = [toggle]\n\n    #     toggle.observe(on_toggle_change, names=\"value\")\n\n    #     def on_button_click(b):\n    #         hbox.close()\n    #         toggle.close()\n    #         dropdown.close()\n    #         button.close()\n\n    #     button.on_click(on_button_click)\n\n    #     def on_dropdown_change(change):\n    #         if change[\"new\"]:\n    #             self.layers = self.layers[:-2]\n    #             self.add_basemap(change[\"new\"])\n\n    #     dropdown.observe(on_dropdown_change, names=\"value\")\n\n    #     control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    #     self.add(control)\n\n    # def add_widget(self, widget, position=\"topright\", **kwargs):\n    #     \"\"\"Add a widget to the map.\n\n    #     Args:\n    #         widget (ipywidgets.Widget): The widget to add.\n    #         position (str, optional): Position of the widget. Defaults to \"topright\".\n    #         **kwargs: Additional keyword arguments for the WidgetControl.\n    #     \"\"\"\n    #     control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    #     self.add(control)\n\n    # to get the points\n    # for category, group in gdf_points.groupby(\"category\"):\n    #     self.add_gdf(\n    #         group,\n    #         style={\n    #             \"color\": category_colors[category],\n    #             \"radius\": 6,\n    #             \"fillOpacity\": 0.7,\n    #         },\n    #         zoom_to_layer=False,\n    #     )\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style={'color': 'yellow', 'fillOpacity': 0.5}, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>_file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Zoom in to the layer on the map. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.</p> <code>{'color': 'yellow', 'fillOpacity': 0.5}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style={\"color\": \"yellow\", \"fillOpacity\": 0.5},\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (_type_): _file path, GeoDataFrame, or GeoJSON dictionary.\n        zoom_to_layer (bool, optional): Zoom in to the layer on the map. Defaults to True.\n        hover_style (dict, optional): Changes color when hover over place on map. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.5}.\n    \"\"\"\n    import json\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n        gdf = gpd.GeoDataFrame.from_features(geojson[\"features\"], crs=\"EPSG:4326\")\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_image","title":"<code>add_image(self, image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>geogo/geogo.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_raster","title":"<code>add_raster(self, filepath, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The file path to the raster file.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.TileLayer layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_raster(self, filepath, **kwargs):\n    \"\"\"Adds a raster layer to the map.\n    Args:\n        filepath (str): The file path to the raster file.\n        **kwargs: Additional keyword arguments for the ipyleaflet.TileLayer layer.\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(filepath)\n    tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_storm_wg","title":"<code>add_storm_wg(self, basin='north_atlantic', options=None, source='hurdat', position='topright', legend=True)</code>","text":"<p>Adds a storm widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basin</code> <code>str</code> <p>The basin of the storm. Defaults to \"north_atlantic\".</p> <code>'north_atlantic'</code> <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].</p> <code>None</code> <code>source</code> <code>str</code> <p>The source of the storm data. Defaults to \"hurdat\".</p> <code>'hurdat'</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <code>legend</code> <code>bool</code> <p>Whether to show a legend for storm categories. Defaults to True.</p> <code>True</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_storm_wg(\n    self,\n    basin=\"north_atlantic\",\n    options=None,\n    source=\"hurdat\",\n    position=\"topright\",\n    legend=True,\n):\n    \"\"\"Adds a storm widget to the map.\n    Args:\n        basin (str): The basin of the storm. Defaults to \"north_atlantic\".\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n        source (str): The source of the storm data. Defaults to \"hurdat\".\n        position (str): The position of the widget on the map. Defaults to \"topright\".\n        legend (bool): Whether to show a legend for storm categories. Defaults to True.\n    \"\"\"\n    import ipywidgets as widgets\n    import tropycal.tracks as tracks\n    from ipyleaflet import LegendControl, WidgetControl\n\n    if options is None:\n        options = [\"OpenStreetMap\", \"OpenTopoMap\", \"Esri.WorldImagery\"]\n\n    toggle_button = widgets.ToggleButton(\n        value=True,\n        icon=\"globe\",\n        tooltip=\"Show/Hide storm &amp; basemap\",\n        layout=widgets.Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    basemap_dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    def on_basemap_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    basemap_dropdown.observe(on_basemap_change, names=\"value\")\n\n    storm_list = [\n        (\"Wilma\", 2005),\n        (\"Katrina\", 2005),\n        (\"Rita\", 2005),\n        (\"Sandy\", 2012),\n        (\"Gert\", 2016),\n        (\"Hermine\", 2016),\n        (\"Matthew\", 2016),\n        (\"Otto\", 2016),\n        (\"Patricia\", 2015),\n        (\"Nate\", 2017),\n        (\"Harvey\", 2017),\n        (\"Irma\", 2017),\n        (\"Michael\", 2018),\n        (\"Dorian\", 2019),\n        (\"Lorenzo\", 2019),\n        (\"Laura\", 2020),\n        (\"Ida\", 2021),\n        (\"Ian\", 2022),\n        (\"Nicole\", 2022),\n        (\"Lee\", 2023),\n        (\"Ophelia\", 2023),\n        (\"Franklin\", 2023),\n        (\"Elsa\", 2021),\n        (\"Fiona\", 2022),\n        (\"Sally\", 2020),\n        (\"Teddy\", 2020),\n        (\"Zeta\", 2020),\n        (\"Helene\", 2024),\n    ]\n    storm_options = [(f\"{s[0]} ({s[1]})\", (s[0].lower(), s[1])) for s in storm_list]\n    default_value = storm_options[0][1]\n\n    storm_dropdown = widgets.Dropdown(\n        options=storm_options,\n        value=default_value,\n        description=\"Storm:\",\n        style={\"description_width\": \"initial\"},\n        layout=widgets.Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    self._storm_dataset = tracks.TrackDataset(basin=basin, source=source)\n    self._current_storm = None\n\n    def on_storm_change(change):\n        if change[\"type\"] == \"change\" and change[\"name\"] == \"value\":\n            storm_name, storm_year = change[\"new\"]\n            self.layers = self.layers[:3]\n            if hasattr(self, \"_storm_layer\") and self._storm_layer in self.layers:\n                self.remove_layer(self._storm_layer)\n            self._storm_layer = self.add_tropycal_storm(\n                (storm_name, storm_year), basin=basin, source=source\n            )\n\n    storm_dropdown.observe(on_storm_change, names=\"value\")\n\n    controls_box = widgets.VBox([basemap_dropdown, storm_dropdown])\n\n    def toggle_visibility(change):\n        controls_box.layout.display = \"flex\" if change[\"new\"] else \"none\"\n\n    toggle_button.observe(toggle_visibility, names=\"value\")\n\n    controls_box.layout.display = \"flex\" if toggle_button.value else \"none\"\n\n    unified_widget = widgets.VBox([toggle_button, controls_box])\n    control = WidgetControl(widget=unified_widget, position=position)\n    self.add(control)\n\n    if legend:\n        category_colors = {\n            \"TD\": \"#6baed6\",\n            \"TS\": \"#3182bd\",\n            \"Category 1\": \"#31a354\",\n            \"Category 2\": \"#addd8e\",\n            \"Category 3\": \"#fdae6b\",\n            \"Category 4\": \"#fd8d3c\",\n            \"Category 5\": \"#e31a1c\",\n        }\n        legend_control = LegendControl(\n            legend=category_colors, title=\"Storm Categories\", position=\"bottomright\"\n        )\n        self.add_control(legend_control)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_time_wms_layer","title":"<code>add_time_wms_layer(self, url='https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi', layers='MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day', time='2020-07-05', format='image/png', transparent=True, attribution='NASA GIBS', name='Time WMS Layer')</code>","text":"<p>Adds a time-enabled WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Map</code> <p>ipyleaflet Map instance.</p> required <code>url</code> <code>str</code> <p>WMS service URL (GIBS or compatible).</p> <code>'https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi'</code> <code>layers</code> <code>str</code> <p>Name of the WMS layer.</p> <code>'MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day'</code> <code>time</code> <code>str</code> <p>Date in 'YYYY-MM-DD' format.</p> <code>'2020-07-05'</code> <code>format</code> <code>str</code> <p>MIME type of the image layer.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>If background should be transparent.</p> <code>True</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>'NASA GIBS'</code> <code>name</code> <code>str</code> <p>Display name for the layer.</p> <code>'Time WMS Layer'</code> <p>Returns:</p> Type Description <code>WMSLayer</code> <p>The added WMS layer.</p> Source code in <code>geogo/geogo.py</code> <pre><code>def add_time_wms_layer(\n    self,\n    url=\"https://gibs.earthdata.nasa.gov/wms/epsg3857/best/wms.cgi\",\n    layers=\"MODIS_Aqua_L3_Land_Surface_Temp_Daily_Day\",\n    time=\"2020-07-05\",\n    format=\"image/png\",\n    transparent=True,\n    attribution=\"NASA GIBS\",\n    name=\"Time WMS Layer\",\n):\n    \"\"\"Adds a time-enabled WMS layer to the map.\n\n    Args:\n        m (Map): ipyleaflet Map instance.\n        url (str): WMS service URL (GIBS or compatible).\n        layers (str): Name of the WMS layer.\n        time (str): Date in 'YYYY-MM-DD' format.\n        format (str): MIME type of the image layer.\n        transparent (bool): If background should be transparent.\n        attribution (str): Attribution text.\n        name (str): Display name for the layer.\n\n    Returns:\n        WMSLayer: The added WMS layer.\n    \"\"\"\n    from ipyleaflet import WMSLayer\n\n    time_url = f\"{url}?TIME={time}\"\n\n    wms_layer = WMSLayer(\n        url=time_url,\n        layers=layers,\n        format=format,\n        transparent=transparent,\n        attribution=attribution,\n        name=name,\n    )\n\n    self.add_layer(wms_layer)\n    return wms_layer\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_tropycal_storm","title":"<code>add_tropycal_storm(self, name_or_tuple, basin='north_atlantic', source='hurdat', zoom_to_layer=True)</code>","text":"<p>Adds a storm track to the map using Tropycal.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_tuple</code> <code>str or tuple</code> <p>The name of the storm or a tuple containing the name and year.</p> required <code>basin</code> <code>str</code> <p>The basin of the storm. Defaults to 'north_atlantic'.</p> <code>'north_atlantic'</code> <code>source</code> <code>str</code> <p>The source of the storm data. Defaults to 'hurdat'.</p> <code>'hurdat'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer after adding it. Defaults to True.</p> <code>True</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_tropycal_storm(\n    self,\n    name_or_tuple,\n    basin=\"north_atlantic\",\n    source=\"hurdat\",\n    zoom_to_layer=True,\n):\n    \"\"\"Adds a storm track to the map using Tropycal.\n    Args:\n        name_or_tuple (str or tuple): The name of the storm or a tuple containing the name and year.\n        basin (str, optional): The basin of the storm. Defaults to 'north_atlantic'.\n        source (str, optional): The source of the storm data. Defaults to 'hurdat'.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it. Defaults to True.\n    \"\"\"\n    import tropycal.tracks as tracks\n    import geopandas as gpd\n    from shapely.geometry import Point, LineString\n    import pandas as pd\n\n    category_colors = {\n        \"TD\": \"#6baed6\",\n        \"TS\": \"#3182bd\",\n        \"C1\": \"#31a354\",\n        \"C2\": \"#addd8e\",\n        \"C3\": \"#fdae6b\",\n        \"C4\": \"#fd8d3c\",\n        \"C5\": \"#e31a1c\",\n    }\n\n    def get_category(vmax):\n        if vmax &lt; 39:\n            return \"TD\"\n        elif vmax &lt; 74:\n            return \"TS\"\n        elif vmax &lt; 96:\n            return \"C1\"\n        elif vmax &lt; 111:\n            return \"C2\"\n        elif vmax &lt; 130:\n            return \"C3\"\n        elif vmax &lt; 157:\n            return \"C4\"\n        else:\n            return \"C5\"\n\n    dataset = tracks.TrackDataset(basin=basin, source=source)\n    storm = dataset.get_storm(name_or_tuple)\n\n    df = pd.DataFrame(\n        {\n            \"datetime\": storm.dict[\"time\"],\n            \"lat\": storm.dict[\"lat\"],\n            \"lon\": storm.dict[\"lon\"],\n            \"vmax\": storm.dict[\"vmax\"],\n            \"mslp\": storm.dict[\"mslp\"],\n            \"type\": storm.dict[\"type\"],\n            \"id\": storm.dict[\"id\"],\n            \"name\": storm.dict[\"name\"],\n        }\n    )\n\n    df[\"category\"] = df[\"vmax\"].apply(get_category)\n    df[\"color\"] = df[\"category\"].map(category_colors)\n    df[\"geometry\"] = [Point(xy) for xy in zip(df.lon, df.lat)]\n    gdf_points = gpd.GeoDataFrame(df, crs=\"EPSG:4326\")\n\n    segments = []\n    for i in range(len(gdf_points) - 1):\n        seg = LineString(\n            [gdf_points.geometry.iloc[i], gdf_points.geometry.iloc[i + 1]]\n        )\n        color = gdf_points.color.iloc[i]\n        segments.append({\"geometry\": seg, \"color\": color})\n\n    gdf_line = gpd.GeoDataFrame(segments, crs=\"EPSG:4326\")\n    for _, row in gdf_line.iterrows():\n        self.add_gdf(\n            gpd.GeoDataFrame([row], crs=\"EPSG:4326\"),\n            style={\"color\": row[\"color\"], \"weight\": 3},\n            zoom_to_layer=False,\n        )\n\n    if zoom_to_layer:\n        self.fit_bounds(\n            gdf_points.total_bounds[[1, 0, 3, 2]].reshape(2, 2).tolist()\n        )\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>geogo/geogo.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_video","title":"<code>add_video(self, video, bounds=None, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_video(self, video, bounds=None, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"geogo/#geogo.geogo.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>geogo/geogo.py</code> <pre><code>def add_wms_layer(\n    self,\n    url,\n    layers,\n    format=\"image/png\",\n    transparent=True,\n    **kwargs,\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    from ipywidgets import DatePicker, Layout\n    from datetime import date\n\n    layers = ipyleaflet.WMSLayer(\n        url=url, layers=layers, format=format, transparent=transparent, **kwargs\n    )\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geogo, run this command in your terminal:</p> <pre><code>pip install geogo\n</code></pre> <p>This is the preferred method to install geogo, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geogo from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/jlhammel/geogo\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geogo in a project:</p> <pre><code>import geogo\n</code></pre>"},{"location":"examples/StormWMS/","title":"StormWMS","text":"<p>Geogo allows you to use WMS data from NASA GIBS to analyse things such as precipitation, vegetation indices and population at the time of a hurricane. You can also change the date of the WMS layer by changing the time variable using the \"year-month-date\" format for the date.</p> In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo <p>Precipitation:</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(\n    layers=\"AMSRE_Surface_Precipitation_Rate_Day\", time=\"2005-07-04\", name=\"NASA\"\n)\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(     layers=\"AMSRE_Surface_Precipitation_Rate_Day\", time=\"2005-07-04\", name=\"NASA\" ) m In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(layers=\"AIRS_Precipitation_Day\", time=\"2024-10-04\", name=\"NASA\")\nm.add_tropycal_storm((\"helene\", 2024))\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(layers=\"AIRS_Precipitation_Day\", time=\"2024-10-04\", name=\"NASA\") m.add_tropycal_storm((\"helene\", 2024)) m In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\"\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\" In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(\n    layers=\"AMSRE_Surface_Precipitation_Rate_Day\", time=\"2024-10-04\", name=\"NASA\"\n)\nm.add_shp(\n    url,\n    zoom_to_layer=False,\n    name=\"U.S. States\",\n    style={\"color\": \"black\", \"fillOpacity\": 0},\n    hover_style={},\n)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(     layers=\"AMSRE_Surface_Precipitation_Rate_Day\", time=\"2024-10-04\", name=\"NASA\" ) m.add_shp(     url,     zoom_to_layer=False,     name=\"U.S. States\",     style={\"color\": \"black\", \"fillOpacity\": 0},     hover_style={}, ) m.add_storm_wg() m <p>Vegetation Indices</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_time_wms_layer(layers=\"MODIS_Aqua_L3_EVI_16Day\", time=\"2005-07-04\", name=\"NASA\")\nm.add_shp(\n    url,\n    zoom_to_layer=False,\n    name=\"U.S. States\",\n    style={\"color\": \"black\", \"fillOpacity\": 0},\n    hover_style={},\n)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_time_wms_layer(layers=\"MODIS_Aqua_L3_EVI_16Day\", time=\"2005-07-04\", name=\"NASA\") m.add_shp(     url,     zoom_to_layer=False,     name=\"U.S. States\",     style={\"color\": \"black\", \"fillOpacity\": 0},     hover_style={}, ) m.add_storm_wg() m"},{"location":"examples/StormWMS/#storm-wms-analysis","title":"Storm WMS Analysis\u00b6","text":""},{"location":"examples/foliummap/","title":"Foliummap","text":"In\u00a0[1]: Copied! <pre>import geogo.foliummap as geogo\n</pre> import geogo.foliummap as geogo In\u00a0[2]: Copied! <pre>m = geogo.Map()\ndata = \"https://github.com/opengeos/datasets/releases/download/world/continents.geojson\"\nm.add_geojson(data, name=\"Continents\")\nm.add_layer_control()\nm\n</pre> m = geogo.Map() data = \"https://github.com/opengeos/datasets/releases/download/world/continents.geojson\" m.add_geojson(data, name=\"Continents\") m.add_layer_control() m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/foliummap/#map","title":"Map\u00b6","text":""},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"},{"location":"examples/leafmap/","title":"Leafmap","text":"In\u00a0[1]: Copied! <pre>import leafmap\nimport geopandas as gpd\n</pre> import leafmap import geopandas as gpd In\u00a0[2]: Copied! <pre>m = leafmap.Map()\nurl = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\nm.add_search_control(url=url, zoom=10, position=\"topleft\")\nm\n</pre> m = leafmap.Map() url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\" m.add_search_control(url=url, zoom=10, position=\"topleft\") m Out[2]: In\u00a0[3]: Copied! <pre>m.clear_controls()\nm\n</pre> m.clear_controls() m Out[3]: In\u00a0[4]: Copied! <pre>m.add_wms_layer(\n    url=\"https://services.terrascope.be/wms/v2?\",\n    layers=\"WORLDCOVER_2021_MAP\",\n    name=\"World Cover\",\n)\nm.add_legend(title=\"World Cover\", builtin_legend=\"ESA_WorldCover\")\nm\n</pre> m.add_wms_layer(     url=\"https://services.terrascope.be/wms/v2?\",     layers=\"WORLDCOVER_2021_MAP\",     name=\"World Cover\", ) m.add_legend(title=\"World Cover\", builtin_legend=\"ESA_WorldCover\") m Out[4]: In\u00a0[5]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"\ngdf = gpd.read_file(url)\n\ngdf[\"latitude\"] = gdf.geometry.y\ngdf[\"longitude\"] = gdf.geometry.x\n\nm = leafmap.Map(center=(gdf.latitude.mean(), gdf.longitude.mean()), zoom=15)\n\nm.add_points_from_xy(\n    gdf, x=\"longitude\", y=\"latitude\", cluster=True, layer_name=\"Building Centroids\"\n)\n\nm\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\" gdf = gpd.read_file(url)  gdf[\"latitude\"] = gdf.geometry.y gdf[\"longitude\"] = gdf.geometry.x  m = leafmap.Map(center=(gdf.latitude.mean(), gdf.longitude.mean()), zoom=15)  m.add_points_from_xy(     gdf, x=\"longitude\", y=\"latitude\", cluster=True, layer_name=\"Building Centroids\" )  m Out[5]: In\u00a0[6]: Copied! <pre>m.add_circle_markers_from_xy(\n    data=\"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\",\n    radius=5,\n    color=\"red\",\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n)\nm\n</pre> m.add_circle_markers_from_xy(     data=\"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\",     radius=5,     color=\"red\",     fill_color=\"yellow\",     fill_opacity=0.8, ) m Out[6]: In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"\nstyle = {\"color\": \"red\", \"fillColor\": \"None\"}\nm.add_vector(url, style=style, layer_name=\"Roads\", zoom_to_layer=True)\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\" style = {\"color\": \"red\", \"fillColor\": \"None\"} m.add_vector(url, style=style, layer_name=\"Roads\", zoom_to_layer=True) m Out[7]: In\u00a0[8]: Copied! <pre>m = leafmap.Map()\ndata = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\"\nstyle = {\"color\": \"red\", \"weight\": 2}\nm.add_vector(\n    data, style=style, layer_name=\"Roads\", info_mode=\"on_hover\", zoom_to_layer=True\n)\nm\n</pre> m = leafmap.Map() data = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\" style = {\"color\": \"red\", \"weight\": 2} m.add_vector(     data, style=style, layer_name=\"Roads\", info_mode=\"on_hover\", zoom_to_layer=True ) m Out[8]: In\u00a0[9]: Copied! <pre>m = leafmap.Map()\ndata = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\"\nm.add_data(\n    data,\n    column=\"CENSUSAREA\",\n    scheme=\"Quantiles\",\n    cmap=\"Blues\",\n    legend_title=\"Population\",\n)\nm\n</pre> m = leafmap.Map() data = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\" m.add_data(     data,     column=\"CENSUSAREA\",     scheme=\"Quantiles\",     cmap=\"Blues\",     legend_title=\"Population\", ) m Out[9]: In\u00a0[10]: Copied! <pre>url = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\nurl2 = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\"\n)\nm = leafmap.Map()\nm.split_map(\n    left_layer=url,\n    right_layer=url2,\n    left_label=\"Pre-event\",\n    right_label=\"Post-event\",\n)\nm\n</pre> url = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) url2 = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\" ) m = leafmap.Map() m.split_map(     left_layer=url,     right_layer=url2,     left_label=\"Pre-event\",     right_label=\"Post-event\", ) m Out[10]:"},{"location":"examples/leafmap/#leafmap-examples","title":"Leafmap Examples\u00b6","text":""},{"location":"examples/map/","title":"Map","text":"In\u00a0[1]: Copied! <pre>import geogo\n</pre> import geogo In\u00a0[2]: Copied! <pre>m = geogo.Map()\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\nm.add_geojson(\n    url, zoom_to_layer=True, name=\"Countries\", hover_style={\"fillColor\": \"red\"}\n)\nm.add_layer_control()\nm\n</pre> m = geogo.Map() url = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" m.add_geojson(     url, zoom_to_layer=True, name=\"Countries\", hover_style={\"fillColor\": \"red\"} ) m.add_layer_control() m Out[2]: In\u00a0[3]: Copied! <pre>m = geogo.Map()\nurl = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\"\nm.add_shp(\n    url, zoom_to_layer=False, name=\"U.S. States\", hover_style={\"fillColor\": \"red\"}\n)\nm.add_layer_control()\nm\n</pre> m = geogo.Map() url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\" m.add_shp(     url, zoom_to_layer=False, name=\"U.S. States\", hover_style={\"fillColor\": \"red\"} ) m.add_layer_control() m <pre>/home/runner/.local/lib/python3.11/site-packages/pyogrio/raw.py:198: RuntimeWarning: /vsizip/vsicurl/https://github.com/opengeos/datasets/releases/download/us/us_states.zip/us_states.shp contains polygon(s) with rings with invalid winding order. Autocorrecting them, but that shapefile should be corrected using ogr2ogr for example.\n  return ogr_read(\n</pre> Out[3]: In\u00a0[4]: Copied! <pre>m = geogo.Map()\ndata = (\n    \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\"\n)\nm.add_vector(data, zoom_to_layer=False, name=\"Cities\", hover_style={\"fillColor\": \"red\"})\nm.add_layer_control()\nm\n</pre> m = geogo.Map() data = (     \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\" ) m.add_vector(data, zoom_to_layer=False, name=\"Cities\", hover_style={\"fillColor\": \"red\"}) m.add_layer_control() m Out[4]: In\u00a0[5]: Copied! <pre>import geogo.foliummap as geogo\n</pre> import geogo.foliummap as geogo In\u00a0[6]: Copied! <pre>m = geogo.Map()\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\nm.add_geojson(\n    url, zoom_to_layer=True, name=\"Countries\", hover_style={\"fillColor\": \"red\"}\n)\nm.add_layer_control()\nm\n</pre> m = geogo.Map() url = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" m.add_geojson(     url, zoom_to_layer=True, name=\"Countries\", hover_style={\"fillColor\": \"red\"} ) m.add_layer_control() m Out[6]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[7]: Copied! <pre>m = geogo.Map()\nurl = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\"\nm.add_shp(\n    url, zoom_to_layer=False, name=\"U.S. States\", hover_style={\"fillColor\": \"red\"}\n)\nm.add_layer_control()\nm\n</pre> m = geogo.Map() url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.zip\" m.add_shp(     url, zoom_to_layer=False, name=\"U.S. States\", hover_style={\"fillColor\": \"red\"} ) m.add_layer_control() m <pre>/home/runner/.local/lib/python3.11/site-packages/pyogrio/raw.py:198: RuntimeWarning: /vsizip/vsicurl/https://github.com/opengeos/datasets/releases/download/us/us_states.zip/us_states.shp contains polygon(s) with rings with invalid winding order. Autocorrecting them, but that shapefile should be corrected using ogr2ogr for example.\n  return ogr_read(\n</pre> Out[7]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[8]: Copied! <pre>m = geogo.Map()\ndata = (\n    \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\"\n)\nm.add_vector(data, zoom_to_layer=False, name=\"Cities\", hover_style={\"fillColor\": \"red\"})\nm.add_layer_control()\nm\n</pre> m = geogo.Map() data = (     \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\" ) m.add_vector(data, zoom_to_layer=False, name=\"Cities\", hover_style={\"fillColor\": \"red\"}) m.add_layer_control() m Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[9]: Copied! <pre>m = geogo.Map()\ndata = \"https://github.com/opengeos/datasets/releases/download/world/continents.geojson\"\nm.add_geojson(data, name=\"Continents\")\nm.add_layer_control()\nm\n</pre> m = geogo.Map() data = \"https://github.com/opengeos/datasets/releases/download/world/continents.geojson\" m.add_geojson(data, name=\"Continents\") m.add_layer_control() m Out[9]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/map/#geogo-map-using-folium-and-ipyleaflet","title":"Geogo Map Using Folium and IPYLeaflet\u00b6","text":""},{"location":"examples/map/#ipyleaflet-demo","title":"IPYLeaflet Demo\u00b6","text":""},{"location":"examples/map/#folium-demo","title":"Folium Demo\u00b6","text":""},{"location":"examples/splitmaps/","title":"Splitmaps","text":"In\u00a0[1]: Copied! <pre>import geogo.foliummap as geogo\n</pre> import geogo.foliummap as geogo In\u00a0[2]: Copied! <pre>m = geogo.Map()\nm.add_split_map()\nm\n</pre> m = geogo.Map() m.add_split_map() m Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>m = geogo.Map()\nm.add_split_map(left=\"Cartodb dark_matter\", right=\"OpenStreetMap\")\nm\n</pre> m = geogo.Map() m.add_split_map(left=\"Cartodb dark_matter\", right=\"OpenStreetMap\") m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>m = geogo.Map()\nm.add_split_map(\n    left=\"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\",\n    right=\"https://github.com/opengeos/datasets/releases/download/raster/landsat7.tif\",\n)\nm\n</pre> m = geogo.Map() m.add_split_map(     left=\"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\",     right=\"https://github.com/opengeos/datasets/releases/download/raster/landsat7.tif\", ) m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/splitmaps/#split-maps-demonstration","title":"Split Maps Demonstration\u00b6","text":""},{"location":"examples/storm/","title":"Storm","text":"<p>Geogo inputs HURDAT2 data onto an interactive map with a dropdown widget allowing for transition between hurricanes.</p> In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_basemap()\nm.add_tropycal_storm((\"helene\", 2024))\nm\n</pre> m = geogo.Map() m.add_basemap() m.add_tropycal_storm((\"helene\", 2024)) m <p>Storm WG allows the user to switch between storms using a dropdown widget and a legend to indicate the hurricane category.</p> In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_storm_wg() m"},{"location":"examples/storm/#tropical-storm-analysis","title":"Tropical Storm Analysis\u00b6","text":""},{"location":"examples/stormriv/","title":"Stormriv","text":"<p>Geogo allows you to input raster, image and video data in order to help visualize hurricane impact.</p> In\u00a0[\u00a0]: Copied! <pre>import geogo\n</pre> import geogo <p>Raster:</p> In\u00a0[\u00a0]: Copied! <pre>filename = \"https://github.com/opengeos/datasets/releases/download/raster/nlcd_2021_land_cover_30m.tif\"\n</pre> filename = \"https://github.com/opengeos/datasets/releases/download/raster/nlcd_2021_land_cover_30m.tif\" In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_raster(filename, colormap=\"accent\", name=\"demo\", opacity=0.5)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_raster(filename, colormap=\"accent\", name=\"demo\", opacity=0.5) m.add_storm_wg() m <p>Image:</p> In\u00a0[\u00a0]: Copied! <pre>imageurl = \"https://www.rmets.org/sites/default/files/2024-10/202409262200_g16_fd_geocolor_hurricane-helene-at-sunset_nolabels-hires.png\"\nbounds = (15.0, -100), (40, -60)\n</pre> imageurl = \"https://www.rmets.org/sites/default/files/2024-10/202409262200_g16_fd_geocolor_hurricane-helene-at-sunset_nolabels-hires.png\" bounds = (15.0, -100), (40, -60) In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_image(imageurl, name=\"image\", opacity=0.7, bounds=bounds)\nm.add_storm_wg()\nm\n</pre> m = geogo.Map() m.add_image(imageurl, name=\"image\", opacity=0.7, bounds=bounds) m.add_storm_wg() m <p>Video:</p> In\u00a0[\u00a0]: Copied! <pre>videourl = \"https://www.shutterstock.com/shutterstock/videos/3539883861/preview/stock-footage-a-fictional-satellite-view-of-a-large-hurricane-approaching-cuba-near-south-america-modified.webm\"\nbounds = (13, -150), (40, -120)\n</pre> videourl = \"https://www.shutterstock.com/shutterstock/videos/3539883861/preview/stock-footage-a-fictional-satellite-view-of-a-large-hurricane-approaching-cuba-near-south-america-modified.webm\" bounds = (13, -150), (40, -120) In\u00a0[\u00a0]: Copied! <pre>m = geogo.Map()\nm.add_video(videourl, name=\"video\", opacity=1, bounds=bounds)\nm\n</pre> m = geogo.Map() m.add_video(videourl, name=\"video\", opacity=1, bounds=bounds) m"},{"location":"examples/stormriv/#raster-image-and-video-maps","title":"Raster, image, and video Maps\u00b6","text":""}]}